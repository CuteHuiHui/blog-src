---
title: 大话设计模式阅读笔记4
date: 2019-01-23
tags: [阅读笔记, 设计模式，python]
---

观察者模式、抽象工厂模式

## 观察者模式

观察者模式：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主体对象。
这个主题对象在状态发生变化时，会通知所有的观察者对象，让它们能够自动更新自己::

    >>> s = ConcreteSubject()
    >>> s.attach(ConcreteObserver(s, 'X'))
    >>> s.attach(ConcreteObserver(s, 'Y'))
    >>> s.attach(ConcreteObserver(s, 'Z'))

    >>> s.subject_state = 'ABC'
    >>> s.notify()
    观察者X的新状态是ABC
    观察者Y的新状态是ABC
    观察者Z的新状态是ABC

当一个对象的改变需要同时改变其他对象的时候，且它不知道具体有多少对象有待改变时，
应该考虑使用观察者模式。

观察者模式所做的工作其实就是解除耦合，让耦合的双方都依赖抽象，而不是依赖于具体。
从而使得各自的变化都不会影响另一边的变化。是依赖倒转原则的最佳体现。

<!--more-->

但是抽象通知者还是依赖抽象观察者。在代码中抽象观察者中有一个update()方法，具体
观察者中都要实现该方法，但是在实际中，可能有一些不一样的操作，根本就不是同名的
方法。这是不足的地方。

```
import abc


class Subject:
    """抽象通知者"""

    def __init__(self):
        self.observers = []

    def attach(self, observer):
        self.observers.append(observer)

    def detach(self, observer):
        self.observers.remove(observer)

    def notify(self):
        for observer in self.observers:
            observer.update()


class Observer(abc.ABC):
    """抽象观察者"""

    @abc.abstractmethod
    def update(self):
        pass


class ConcreteSubject(Subject):
    """具体通知者"""

    def __init__(self):
        self.subject_state = None
        super().__init__()


class ConcreteObserver(Observer):
    """具体观察者"""

    def __init__(self, subject, name):
        self.name = name
        self.subject = subject

    def update(self):
        observer_state = self.subject.subject_state
        print('观察者{0}的新状态是{1}'.format(self.name, observer_state))


if __name__ == '__main__':
    s = ConcreteSubject()
    s.attach(ConcreteObserver(s, 'X'))
    s.attach(ConcreteObserver(s, 'Y'))
    s.attach(ConcreteObserver(s, 'Z'))

    s.subject_state = 'ABC'
    s.notify()
```

## 抽象工厂模式


抽象工厂方法：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体
的类::

```
    >>> user = User()
    >>> dept = Department()
    >>> factory = SqlserverFactory()
    >>> iu = factory.create_user()
    >>> iu.insert(user)
    在sql server 中给User表增加一条记录
    >>> iu.get_user(1)
    在sql server 中根据ID得到User表一条记录

    >>> factory = AccessFactory()
    >>> id = factory.create_department()
    >>> id.insert(dept)
    在Access中给Department表增加一条记录
    >>> id.get_dept(1)
    在Access中根据ID得到Department表一条记录
    >>> iu = factory.create_user()
    >>> iu.insert(user)
    在Access中给User表增加一条记录
    >>> iu.get_user(1)
    在Access中根据Id得到User表一条记录

```

抽象工厂模式的优点：

- 1、易于交换产品系列，由于具体工厂类，在一个应用中只需要在初始化的时候出现一次，
这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不 同
的产品配置。
- 2、让具体的创建实例过程和客户端分离，客户端是通过它们的抽象接口操作实例，产品
的具体类名也被具体工厂的实现分离，不会出现在客户代码中。

缺点：
新增或修改时，可能需要大量的改动。

```
import abc


class User:

    id = None
    name = None


class Department:
    id = None
    dept_name = None


class IUser(abc.ABC):

    @abc.abstractmethod
    def insert(self, user):
        pass

    @abc.abstractmethod
    def get_user(self, id):
        pass


class IDepartment(abc.ABC):

    @abc.abstractmethod
    def insert(self, dept):
        pass

    @abc.abstractmethod
    def get_dept(self, id):
        pass


class IFactory(abc.ABC):

    @abc.abstractmethod
    def create_user(self):
        pass

    @abc.abstractmethod
    def create_department(self):
        pass


class SqlserverUser(IUser):

    def insert(self, user):
        print('在sql server 中给User表增加一条记录')

    def get_user(self, id):
        print('在sql server 中根据ID得到User表一条记录')
        return None


class SqlserverDepartment(IDepartment):

    def insert(self, dept):
        print('在sql server 中给Department表中增加一条记录')

    def get_dept(self, id):
        print('在sql server 中根据ID得到Department表一条记录')


class AccessUser(IUser):

    def insert(self, user):
        print('在Access中给User表增加一条记录')

    def get_user(self, id):
        print('在Access中根据Id得到User表一条记录')


class AccessDepartment(IDepartment):

    def insert(self, department):
        print('在Access中给Department表增加一条记录')

    def get_dept(self, id):
        print('在Access中根据ID得到Department表一条记录')


class SqlserverFactory(IFactory):

    def create_user(self):
        return SqlserverUser()

    def create_department(self):
        return SqlserverDepartment()


class AccessFactory(IFactory):

    def create_user(self):
        return AccessUser()

    def create_department(self):
        return AccessDepartment()


if __name__ == '__main__':
    user = User()
    dept = Department()
    # factory = SqlserverFactory()
    factory = AccessFactory()

    iu = factory.create_user()
    iu.insert(user)
    iu.get_user(1)

    id = factory.create_department()
    id.insert(dept)
    id.get_dept(1)
```
