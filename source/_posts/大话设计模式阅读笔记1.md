---
title: 大话设计模式阅读笔记0
date: 2019-01-18
tags: [阅读笔记, 设计模式，python]
---

简单工厂模式、策略模式、装饰模式。


## 简单工厂模式

```
>>> oper = OperationFactory.create_operate('+')
>>> oper.number1 = 12
>>> oper.number2 = 13
>>> oper.get_result()
25
>>> oper = OperationFactory.create_operate('/')
>>> oper.number1 = 12
>>> oper.number2 = 0
>>> oper.get_result()
Traceback (most recent call last):
	...
ValueError: 除数不能为0
```

<!--more-->

`simple_factory.py`

```python
import abc


class Operation(abc.ABC):
    """运算类，抽象类"""
    def __init__(self):
        self._number1 = None
        self._number2 = None

    @property
    def number1(self):
        return self._number1

    @number1.setter
    def number1(self, value):
        self._number1 = value

    @property
    def number2(self):
        return self._number2

    @number2.setter
    def number2(self, value):
        self._number2 = value

    @abc.abstractmethod
    def get_result(self):
        """返回计算结果, 子类需要实现该方法"""


class OperationAdd(Operation):
    """加法类"""
    def get_result(self):
        return self.number1 + self.number2


class OperationSub(Operation):
    """减法类"""
    def get_result(self):
        return self.number1 - self.number2


class OperationMul(Operation):
    """乘法类"""
    def get_result(self):
        return self.number1 * self.number2


class OperationDiv(Operation):
    """除法类"""
    def get_result(self):
        if self.number2 == 0:
            raise ValueError('除数不能为0')
        return self.number1 / self.number2


class OperationFactory:
    """简单运算工厂类"""
    @classmethod
    def create_operate(cls, operate):
        oper = None
        if operate == '+':
            oper = OperationAdd()
        elif operate == '-':
            oper = OperationSub()
        elif operate == '*':
            oper = OperationMul()
        elif operate == '/':
            oper = OperationDiv()
        return oper
```


## 策略模式

策略模式：它定义了算法家族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。

```

>>> csuper = CashContext('正常收费')
>>> csuper.get_result(20)
20.0
>>> csuper = CashContext('满300返100')
>>> csuper.get_result(300)
200.0
>>> csuper.get_result(200)
200.0
>>> csuper = CashContext('打八折')
>>> csuper.get_result(300)
240.0
```

策略模式就是用来封装算法的，但是在实践中，我们可以用它来封装几乎任何类型的规则，只要在分析过程中根据需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。

```
import abc


class CashSuper(abc.ABC):

    @abc.abstractmethod
    def accept_cash(self, money):
        """现金收取超类的抽象方法，收取现金参数为原价，返回为当前价"""


class CashNormal(CashSuper):
    """原价收费"""

    def accept_cash(self, money):
        return float(money)


class CashRebate(CashSuper):
    """打折收费"""

    def __init__(self, money_rebate):
        self.money_rebate = float(money_rebate)

    def accept_cash(self, money):
        return money * self.money_rebate


class CashReturn(CashSuper):
    """返利收费"""

    def __init__(self, money_condition, money_return):
        self.money_condition = float(money_condition)
        self.money_return = float(money_return)

    def accept_cash(self, money):
        money = float(money)
        result = money
        if money >= self.money_condition:
            result = money - money / self.money_condition * self.money_return
        return result


class CashContext:

    def __init__(self, type):
        if type == '正常收费':
            self.cs = CashNormal()
        elif type == '满300返100':
            self.cs = CashReturn('300', '100')
        elif type == "打八折":
            self.cs = CashRebate('0.8')
        else:
            raise ValueError('输入错误')

    def get_result(self, money):
        return self.cs.accept_cash(money)
```

## 装饰模式

装饰模式：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更灵活。

装饰模式的优点就是把类中的装饰功能从类中搬移去除，这样可以简化原有的类。有效地把类的核心职责和装饰功能区分开了，而且可以去除相关类中的重复的装饰逻辑。

```

import abc


class Person:
    def __init__(self, name):
        self.name = name

    def show(self):
        print('装扮的{}'.format(self.name))


class Finery(abc.ABC):

    def decorate(self, component):
        self.component = component

    @abc.abstractmethod
    def show(self):
        """抽象类方法"""
        if self.component:
            self.component.show()


class TShirts(Finery):

    def show(self):
        print('大T恤')
        Finery.show(self)


class BigTrouser(Finery):

    def show(self):
        print('垮裤')
        Finery.show(self)


class WearSneakers(Finery):

    def show(self):
        print('破球鞋')
        Finery.show(self)


class WearSuit(Finery):

    def show(self):
        print('西装')
        Finery.show(self)


class WearTie(Finery):

    def show(self):
        print('领带')
        Finery.show(self)


class WearLeatherShoes(Finery):

    def show(self):
        print('皮鞋')
        Finery.show(self)


if __name__ == '__main__':
    xc = Person('小菜')
    print('第一种装扮')
    pqx = WearSneakers()
    kk = BigTrouser()
    dtx = TShirts()

    pqx.decorate(xc)
    kk.decorate(pqx)
    dtx.decorate(kk)
    dtx.show()
```
