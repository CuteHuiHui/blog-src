---
title: 大话设计模式阅读笔记5
date: 2019-01-25
tags: [阅读笔记, 设计模式, python]
---

状态模式、适配器模式、备忘录模式


## 状态模式

状态模式：当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是一个改变了其类::

```python
>>> c = Context(ConcreteStateA())
>>> c.request()
当前状态：stateB
>>> c.request()
当前状态：stateA
>>> c.request()
当前状态：stateB
>>> c.request()
当前状态：stateA
>>> c.request()
当前状态：stateB
```

状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况，把状态的判断转移到表示不同状态的一系列类中可以把复杂的判断逻辑简化。

状态模式的好处是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。

<!--more-->

```python
import abc


class State(abc.ABC):
    """抽象状态类，定义一个接口以封装一个特定状态相关的行为"""
    @abc.abstractmethod
    def headle(self, context):
        pass


class ConcreteStateA(State):
    """具体状态类"""
    def __init__(self):
        self.name = 'stateA'

    def headle(self, context):
        context.state = ConcreteStateB()


class ConcreteStateB(State):
    def __init__(self):
        self.name = 'stateB'

    def headle(self, context):
        context.state = ConcreteStateA()


class Context:
    """这个类的实例定义当前的状态。"""
    def __init__(self, state):
        """初始状态"""
        self._state = state

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, value):
        self._state = value
        print('当前状态：{}'.format(self._state.name))

    def request(self):
        self.state.headle(self)


if __name__ == '__main__':
    c = Context(ConcreteStateA())

    c.request()
    c.request()
    c.request()
    c.request()
    c.request()
```

## 适配器模式

适配器模式：将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容
而不能一起工作的那些类可以一起工作::

    >>> target = Adapter()
    >>> target.request()
    特殊请求

```python
import abc


class Target(abc.ABC):
    """这是客户期待的接口，目标可以是具体的或抽象的类，也可以是接口"""

    @abc.abstractmethod
    def request(self):
        print('普通请求')


class Adaptee:
    """需要适配的类"""
    def specific_request(self):
        print('特殊请求')


class Adapter(Target):
    """通过内部包装一个Adaptee对象，把源接口转换成目标接口"""

    def __init__(self):
        self.adaptee = Adaptee()

    def request(self):
        return self.adaptee.specific_request()


if __name__ == "__main__":
    target = Adapter()
    target.request()
```

## 备忘录模式

备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存
这个状态。这样就可以将该对象恢复到原先保存的状态::

    >>> o = Originator()
    >>> o.state = 'ON'  # 初始状态
    >>> o.show()
    state= ON

    >>> caretaker = Caretaker()
    >>> caretaker.memento = o.create_memento()

    >>> o.state = 'OFF'  # 改变状态
    >>> o.show()
    state= OFF

    >>> o.set_memento(caretaker.memento)  # 恢复
    >>> o.show()
    state= ON

缺点：当需要备忘的对象状态数据很大很多时，那么在资源消耗上，备忘录对象会非常消耗资源。

``` python
class Originator:

    def __init__(self):
        self.state = None

    def create_memento(self):
        """创建备忘录，将当前需要保存的信息导入并实例化一个备忘录对象。"""
        return Memento(self.state)

    def set_memento(self, memento):
        """恢复备忘录"""
        self.state = memento.state

    def show(self):
        print('state=', self.state)


class Memento:
    """备忘录"""

    def __init__(self, state):
        self.state = state


class Caretaker:
    """管理者，负责保存好备忘录，不能对备忘录的内容进行操作或检查。"""

    def __init__(self):
        self.memento = None


if __name__ == '__main__':
    o = Originator()
    o.state = 'ON'  # 初始状态
    o.show()

    caretaker = Caretaker()
    caretaker.memento = o.create_memento()

    o.state = 'OFF'  # 改变状态
    o.show()

    o.set_memento(caretaker.memento)  # 恢复
    o.show()
```
