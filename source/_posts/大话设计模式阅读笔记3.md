---
title: 大话设计模式阅读笔记3
date: 2019-01-22
tags: [阅读笔记, 设计模式，python]
---

## 模板方法模式
模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，模板方法是的子类可以
不改变一个算法的结构即可重新定义该算法的特定步骤::

```
>>> a = ConcreteClassA()
>>> a.template_method()
具体类A方法1实现
具体类A方法2实现
>>> b = ConcreteClassB()
>>> b.template_method()
具体类B方法1实现
具体类B方法2实现
```

`template_method.py`

```
import abc


class AbstractClass(abc.ABC):

    def template_method(self):
        """模板方法，给出逻辑的骨架，而逻辑的组成是一些相应的抽象操作，它们都推迟到子类实现。"""
        self.primitive_operation1()
        self.primitive_operation2()

    @abc.abstractmethod
    def primitive_operation1(self):
        """抽象行为1放到子类去实现"""

    @abc.abstractmethod
    def primitive_operation2(self):
        """抽象行为2放到子类去实现"""


class ConcreteClassA(AbstractClass):

    def primitive_operation1(slef):
        print('具体类A方法1实现')

    def primitive_operation2(slef):
        print('具体类A方法2实现')


class ConcreteClassB(AbstractClass):

    def primitive_operation1(slef):
        print('具体类B方法1实现')

    def primitive_operation2(slef):
        print('具体类B方法2实现')


if __name__ == '__main__':
    c = ConcreteClassA()
    c.template_method()

    d = ConcreteClassB()
    d.template_method()
```


## 外观模式

外观模式：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，
这个接口使得这一子系统更加容易使用::
```
>>> facade = Facade()
>>> facade.method_a()
--- 方法组A() ---
子系统方法一
子系统方法二
子系统方法四
>>> facade.method_b()
--- 方法组B() ---
子系统方法二
子系统方法三
```

外观模式完美的体现了依赖倒转原则和迪米特法则的思想，是常用的模式之一。
经典的三层架构，就需要考虑在层与层之间建立外观Facade。

`facade.py`

```
class SubSystemOne:

    def methode_one(self):
        print('子系统方法一')


class SubSystemTwo:

    def methode_two(self):
        print('子系统方法二')


class SubSystemThree:

    def methode_three(self):
        print('子系统方法三')


class SubSystemFour:

    def methode_four(self):
        print('子系统方法四')


class Facade:
    """外观类"""

    def __init__(self):
        self.one = SubSystemOne()
        self.two = SubSystemTwo()
        self.three = SubSystemThree()
        self.four = SubSystemFour()

    def method_a(self):
        print('--- 方法组A() ---')
        self.one.methode_one()
        self.two.methode_two()
        self.four.methode_four()

    def method_b(self):
        print('--- 方法组B() ---')
        self.two.methode_two()
        self.three.methode_three()


if __name__ == '__main__':
    facade = Facade()
    facade.method_a()
    facade.method_b()
```

## 建造者模式

建造者模式：将一个复杂对象的构建与它的表示分离，是的同样的构建过程，可以创建不同的表示::

```
>>> director = Director()
>>> b1 = ConcreateBuilder1()
>>> b2 = ConcreateBuilder2()

>>> director.construct(b1)
>>> p1 = b1.get_result()
>>> p1.show()
产品 创建 ----
部件A
部件B

>>> director.construct(b2)
>>> p2 = b2.get_result()
>>> p2.show()
产品 创建 ----
部件X
部件Y
```

建造者模式是当常见复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时使用的模式。

如果我们用了建造者模式，那么用户就只需指定需要建造的类型就可以得到他们，而具体建造的过程
和细节就不需要知道了。

`builder.py`

```

import abc


class Product:
    '''产品类'''

    def __init__(self):
        self.parts = []

    def add(self, part):
        self.parts.append(part)

    def show(self):
        print('产品 创建 ----')
        for item in self.parts:
            print(item)


class Builder(abc.ABC):

    @abc.abstractmethod
    def build_part_a(self):
        '''抽象方法A'''

    @abc.abstractmethod
    def build_part_b(self):
        '''抽象方法B'''

    @abc.abstractmethod
    def get_result(self):
        '''抽象方法C'''


class ConcreateBuilder1(Builder):
    '''具体构建者，继承Builder接口，构造和装配各个部件。'''

    def __init__(self):
        self.product = Product()

    def build_part_a(self):
        self.product.add('部件A')

    def build_part_b(self):
        self.product.add('部件B')

    def get_result(self):
        return self.product


class ConcreateBuilder2(Builder):
    '''具体构建者，继承Builder接口，构造和装配各个部件。'''

    def __init__(self):
        self.product = Product()

    def build_part_a(self):
        self.product.add('部件X')

    def build_part_b(self):
        self.product.add('部件Y')

    def get_result(self):
        return self.product


class Director:
    '''指挥者，用来创建产品'''

    def construct(self, builder):
        builder.build_part_a()
        builder.build_part_b()


if __name__ == '__main__':
    director = Director()
    b1 = ConcreateBuilder1()
    b2 = ConcreateBuilder2()

    director.construct(b1)
    p1 = b1.get_result()
    p1.show()

    director.construct(b2)
    p2 = b2.get_result()
    p2.show()
```
