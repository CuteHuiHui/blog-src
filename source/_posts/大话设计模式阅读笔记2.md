---
title: 大话设计模式阅读笔记2
date: 2019-01-21
tags: [阅读笔记, 设计模式，python]
---

代理模式、工厂方法模式、原型模式。


## 代理模式

为其他对象提供一种代理以控制对这个对象的访问。

代码示例：A追求C，委托B送礼物给C。需求的重点是A和C不能直接接触::

```
>>> jiaojiao = SchoolGirl()
>>> jiaojiao.name = '李娇娇'
```

<!--more-->

`proxy.py`

```
import abc


class SchoolGirl:

    def __init__(self, name):
        self.name = name


class IGiveGift(abc.ABC):
    """代理接口"""

    @abc.abstractmethod
    def give_dolls(self):
        """送洋娃娃"""

    @abc.abstractmethod
    def give_flowers(self):
        """送鲜花"""

    @abc.abstractmethod
    def give_chocolate(self):
        """送巧克力"""


class Pursuit(IGiveGift):
    """追求者"""

    def __init__(self, mm):
        self.mm = mm

    def give_dolls(self):
        print(self.mm.name, '送你洋娃娃')

    def give_flowers(self):
        print(self.mm.name, '送你鲜花')

    def give_chocolate(self):
        print(self.mm.name, '送你巧克力')


class Proxy(IGiveGift):
    """代理者"""

    def __init__(self, mm):
        self.gg = Pursuit(mm)

    def give_dolls(self):
        self.gg.give_dolls()

    def give_flowers(self):
        self.gg.give_flowers()

    def give_chocolate(self):
        self.gg.give_chocolate()


if __name__ == '__main__':
    c = SchoolGirl('c')

    a = Pursuit(c)
    a.give_dolls()
    a.give_flowers()
    a.give_chocolate()
```


## 工厂方法模式


工厂方法模式，定义一个用于创建对象的接口，让子类决定实例化哪个类。
工厂方法使一个类的实例化延迟到其子类。

代码示例：学习雷锋好榜样，继承雷锋精神的大学生和社区的构建::

```
>>> factory = UndergraduateFactory()
>>> student = factory.create_leifeng()
>>> student.buyrice()
买米
>>> student.sweep()
扫地
>>> student.wash()
洗衣

```

工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。

`factory_method.py`

```
import abc


class LeiFeng:

    def sweep(self):
        print('扫地')

    def wash(self):
        print('洗衣')

    def buyrice(self):
        print('买米')


class IFactory(abc.ABC):

    @abc.abstractmethod
    def create_leifeng(self):
        """工厂接口"""


class Undergraduate(LeiFeng):
    """继承雷锋精神的大学生类"""


class Volunteer(LeiFeng):
    """继承雷锋精神的社区志愿者类"""


class UndergraduateFactory(IFactory):
    """大学生工厂"""

    def create_leifeng(self):
        return Undergraduate()


class VolunteerFactory(IFactory):
    """社区志愿者工厂"""

    def create_leifeng(self):
        return Volunteer()


if __name__ == '__main__':
    factory = UndergraduateFactory()  # 要换成 “社区志愿者”，修改这里就可以了
    student = factory.create_leifeng()

    student.buyrice()
    student.sweep()
    student.wash()
```


## 原型模式

原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
其实就是从一个对象再创建另外一个可定制的对象，并且不需要知道任何创建的细节::
```

>>> a = Resume('大鸟')
>>> a.set_personal_info('男', '29')
>>> a.set_work_experience('1998-2000', 'xx公司')

>>> b = a.clone()
>>> b.set_work_experience('2000-2006', 'xx企业')

>>> c = a.clone()
>>> c.set_personal_info('男', '24')

>>> a.display()
大鸟 男 29
工作经历: 1998-2000 xx公司
>>> b.display()
大鸟 男 29
工作经历: 2000-2006 xx企业
>>> c.display()
大鸟 男 24
工作经历: 1998-2000 xx公司
```

一般在初始化的信息不发生变化的情况下，克隆是最好的办法，它既隐藏了对象的创建
细节，又对性能是大大的提升。

`prototype.py`

```
import abc
import copy


class Prototype(abc.ABC):

    @abc.abstractmethod
    def clone(self):
        """"""


class Resume(Prototype):

    def __init__(self, name):
        self.name = name

    def set_personal_info(self, sex, age):
        self.sex = sex
        self.age = age

    def set_work_experience(self, time_area, company):
        self.time_area = time_area
        self.company = company

    def display(self):
        print('{} {} {}'.format(self.name, self.sex, self.age))
        print('工作经历: {} {}'.format(self.time_area, self.company))

    def clone(self):
        return copy.copy(self)


if __name__ == '__main__':
    a = Resume('大鸟')
    a.set_personal_info('男', '29')
    a.set_work_experience('1998-2000', 'xx公司')

    b = a.clone()
    b.set_work_experience('2000-2006', 'xx企业')

    c = a.clone()
    c.set_personal_info('男', '24')

    a.display()
    b.display()
    c.display()
```
